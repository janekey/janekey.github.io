---
layout: post
title: JVM系列：一、JVM组成及内存分配
categories: Java
description: JVM组成及内存分配
keywords: JVM系列
---

    Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人想出来。

![](http://img.blog.csdn.net/20141028171626937)

其中方法区和堆是所有线程共享；虚拟机栈、本地方法栈和程序计数器是各线程独立的。

# 一、运行时数据区

1. 程序计数器
    - 用于当前线程中指示所执行到的位置。字节码解释器就是通过这个值来决定下一个指令。而在多线程中，处理器切换线程时需要知道当前线程执行到的位置，所以程序计数器的存储是各线程独立的。
2. Java虚拟机栈
    - 也是每个线程独享的，生命周期与线程相同。每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。
3. 本地方法栈
    - 与Java虚拟机栈作用相似，区别是Java虚拟机栈是为Java方法服务，而本地方法栈是为Native方法服务。
4. Java堆
    - 是所有线程共享的，在虚拟机启动时创建。几乎所有的对象实例都在堆中分配，Java堆也是垃圾收集器管理的主要区域。
5. 方法区
    - 同样是各线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。垃圾收集在这个区域是比较少出现的，具体看各个虚拟机的实现。

# 二、堆的分区机制

程序运行中，创建的对象比较多时，堆内存中的对象就会比较多，这时就需要垃圾回收（GC）来防止内存溢出。如果GC依次判断各对象是否需要回收那效率就太低了，所以JVM对堆内存采用了分区管理的机制。

堆内存分为下面三个区域：

1. Young Generation Space新生代（新生代又分为三部分）
    - Eden Space
    - 0 Survivor Space（S0）
    - 1 Survivor Space（S1）
2. Tenure Generation Space旧生代
3. Permanent Space持久代（方法区）（方法区物理上存在堆中，逻辑上和堆是独立的）

![](http://img.blog.csdn.net/20141028171824066)